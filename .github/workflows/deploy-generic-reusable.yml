name: Reusable Generic Application Deployment

'on':
  workflow_call:
    inputs:
      config_file:
        description: 'Path to deployment config file'
        required: false
        type: string
        default: 'deployment-generic.config.yml'
      aws_region:
        description: 'AWS region (overrides config)'
        required: false
        type: string
      instance_name:
        description: 'Lightsail instance name (overrides config)'
        required: false
        type: string
      skip_tests:
        description: 'Skip test job'
        required: false
        type: boolean
        default: false
      environment:
        description: 'GitHub environment to use'
        required: false
        type: string
      docker_image_tag:
        description: 'Pre-built Docker image tag to use'
        required: false
        type: string
    outputs:
      deployment_url:
        description: 'URL of deployed application'
        value: ${{ jobs.verification.outputs.app_url }}
      deployment_status:
        description: 'Status of deployment'
        value: ${{ jobs.verification.outputs.status }}

permissions:
  id-token: write   # Required for OIDC authentication
  contents: read    # Required to checkout code

jobs:
  load-config:
    runs-on: ubuntu-latest
    outputs:
      instance_name: ${{ steps.config.outputs.instance_name }}
      static_ip: ${{ steps.config.outputs.static_ip }}
      aws_region: ${{ steps.config.outputs.aws_region }}
      app_name: ${{ steps.config.outputs.app_name }}
      app_type: ${{ steps.config.outputs.app_type }}
      app_version: ${{ steps.config.outputs.app_version }}
      should_deploy: ${{ steps.config.outputs.should_deploy }}
      enabled_dependencies: ${{ steps.config.outputs.enabled_dependencies }}
      test_enabled: ${{ steps.config.outputs.test_enabled }}
      os_type: ${{ steps.config.outputs.os_type }}
      package_manager: ${{ steps.config.outputs.package_manager }}
      verification_port: ${{ steps.config.outputs.verification_port }}
      verification_path: ${{ steps.config.outputs.verification_path }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ vars.AWS_ROLE_ARN || secrets.AWS_ROLE_ARN }}
        role-duration-seconds: 3600  # 1 hour session
        aws-region: us-east-1

    - name: Setup Python
      run: python3 -m pip install --upgrade pip boto3

    - name: Checkout deployment scripts
      uses: actions/checkout@v4
      with:
        repository: naveenraj44125-creator/lamp-stack-lightsail
        ref: main
        path: .deployment-scripts
        token: ${{ github.token }}
    
    - name: Copy deployment scripts
      run: |
        mkdir -p workflows
        cp -r .deployment-scripts/workflows/* ./workflows/
        ls -la workflows/
        echo "‚úÖ Deployment scripts copied"

    - name: Load Configuration and Setup Instance
      id: config
      run: |
        echo "üîß Running instance setup script..."
        export CONFIG_FILE="${{ inputs.config_file }}"
        export INSTANCE_NAME="${{ inputs.instance_name }}"
        export AWS_REGION="${{ inputs.aws_region }}"
        export SKIP_TESTS="${{ inputs.skip_tests }}"
        
        python3 workflows/setup_instance.py

  test:
    needs: load-config
    runs-on: ubuntu-latest
    if: needs.load-config.outputs.test_enabled == 'true'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Test Environment
      run: |
        echo "üîß Setting up test environment for ${{ needs.load-config.outputs.app_type }} application"
        echo "üì¶ Dependencies: ${{ needs.load-config.outputs.enabled_dependencies }}"

    - name: Setup PHP (if PHP dependency enabled)
      if: contains(needs.load-config.outputs.enabled_dependencies, 'php')
      uses: shivammathur/setup-php@v2
      with:
        php-version: '8.1'
        extensions: pdo, pdo_mysql, curl, json, mbstring

    - name: Validate PHP syntax (if PHP enabled)
      if: contains(needs.load-config.outputs.enabled_dependencies, 'php')
      run: |
        echo "üîç Validating PHP syntax..."
        find . -name "*.php" -exec php -l {} \;

    - name: Test PHP application (if PHP enabled)
      if: contains(needs.load-config.outputs.enabled_dependencies, 'php')
      run: |
        echo "üß™ Testing PHP application..."
        # Find the PHP application directory
        if [ -d "example-lamp-app" ]; then
          cd example-lamp-app
        fi
        
        # Start PHP server
        if [ -f "index.php" ]; then
          php -S localhost:8000 index.php &
          sleep 5
          curl -f http://localhost:8000/ || exit 1
          echo "‚úÖ PHP application test passed"
        else
          echo "‚ö†Ô∏è  No index.php found, skipping PHP server test"
        fi

    - name: Setup Python (if Python dependency enabled)
      if: contains(needs.load-config.outputs.enabled_dependencies, 'python')
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Test Python application (if Python enabled)
      if: contains(needs.load-config.outputs.enabled_dependencies, 'python')
      run: |
        echo "üß™ Testing Python application..."
        
        # Find the Python application directory
        if [ -d "example-python-app" ]; then
          cd example-python-app
        fi
        
        # Install dependencies
        if [ -f "requirements.txt" ]; then
          pip install -r requirements.txt
          echo "‚úÖ Dependencies installed"
        fi
        
        # Test Flask application
        if [ -f "app.py" ]; then
          # Syntax check
          python -m py_compile app.py
          echo "‚úÖ Python syntax validation passed"
          
          # Start Flask app and test
          python app.py &
          APP_PID=$!
          sleep 5
          
          # Test endpoints
          if curl -f http://localhost:5000/api/health 2>/dev/null; then
            echo "‚úÖ Flask application is responding"
            kill $APP_PID
          else
            echo "‚ö†Ô∏è  Flask application not responding, but syntax is valid"
            kill $APP_PID 2>/dev/null || true
          fi
        else
          echo "‚ö†Ô∏è  No app.py found, skipping Flask test"
        fi

    - name: Setup Node.js (if Node.js dependency enabled)
      if: contains(needs.load-config.outputs.enabled_dependencies, 'nodejs')
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Test Node.js application (if Node.js enabled)
      if: contains(needs.load-config.outputs.enabled_dependencies, 'nodejs')
      run: |
        echo "üß™ Testing Node.js application..."
        if [ -f "package.json" ]; then
          npm install
          npm test || echo "No test script found"
        fi
        if [ -f "app.js" ] || [ -f "index.js" ]; then
          node -c app.js || node -c index.js || echo "‚úÖ Node.js syntax validation passed"
        fi

    - name: Generic Application Tests
      run: |
        echo "üß™ Running generic application tests..."
        
        # Check for main application files in subdirectories
        if [ -f "index.html" ] || [ -f "index.php" ] || [ -f "app.py" ] || [ -f "app.js" ] || \
           [ -f "example-lamp-app/index.php" ] || [ -f "example-nodejs-app/app.js" ] || [ -f "example-python-app/app.py" ]; then
          echo "‚úÖ Main application file found"
        else
          echo "‚ö†Ô∏è  No main application file detected"
        fi
        
        if [ -f "${{ inputs.config_file }}" ]; then
          pip install PyYAML
          python3 -c "import yaml; yaml.safe_load(open('${{ inputs.config_file }}'))"
          echo "‚úÖ Configuration file is valid YAML"
        fi

  pre-steps-generic:
    needs: [load-config, test]
    runs-on: ubuntu-latest
    timeout-minutes: 25
    if: |
      always() &&
      needs.load-config.outputs.should_deploy == 'true' &&
      (needs.test.result == 'success' || needs.test.result == 'skipped')
    environment: ${{ inputs.environment }}
    steps:
    - name: Checkout application code
      uses: actions/checkout@v4
    
    - name: Checkout deployment scripts
      uses: actions/checkout@v4
      with:
        repository: naveenraj44125-creator/lamp-stack-lightsail
        ref: main
        path: .deployment-scripts
        token: ${{ github.token }}
    
    - name: Copy deployment scripts
      run: |
        mkdir -p workflows
        cp -r .deployment-scripts/workflows/* ./workflows/
        ls -la workflows/
        echo "‚úÖ Deployment scripts copied"
    
    - name: Debug Deployment Decision
      run: |
        echo "üîç Deployment Debug Information:"
        echo "Should Deploy: ${{ needs.load-config.outputs.should_deploy }}"
        echo "Instance Name: ${{ needs.load-config.outputs.instance_name }}"
        echo "AWS Region: ${{ needs.load-config.outputs.aws_region }}"
        echo "Dependencies: ${{ needs.load-config.outputs.enabled_dependencies }}"

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ vars.AWS_ROLE_ARN || secrets.AWS_ROLE_ARN }}
        role-duration-seconds: 3600  # 1 hour session
        aws-region: ${{ needs.load-config.outputs.aws_region }}

    - name: Setup Python environment
      run: |
        python3 -m pip install --upgrade pip
        python3 -m pip install boto3 pyyaml

    - name: Pre-flight Instance Health Check
      run: |
        echo "üè• Running pre-flight health check..."
        export PYTHONPATH="${PYTHONPATH}:$(pwd)/workflows"
        export GITHUB_ACTIONS=true
        
        python3 << 'EOF'
        import sys
        import os
        sys.path.insert(0, 'workflows')
        from lightsail_common import LightsailBase
        
        instance_name = "${{ needs.load-config.outputs.instance_name }}"
        region = "${{ needs.load-config.outputs.aws_region }}"
        
        client = LightsailBase(instance_name, region)
        
        print(f"üîç Enhanced pre-flight check for {instance_name}...")
        
        # Test SSH connectivity first with enhanced retries
        print("üîó Testing SSH connectivity with enhanced retries...")
        ssh_success = client.test_ssh_connectivity(timeout=60, max_retries=5)
        
        if not ssh_success:
            print("‚ö†Ô∏è  SSH connectivity issues detected")
            print("   This may be due to temporary network issues or instance startup")
            print("   Deployment will continue - the instance may still be functional")
        else:
            print("‚úÖ SSH connectivity confirmed")
            
            # Only run dpkg check if SSH is working
            print("üîß Running dpkg health check...")
            script = '''
            if sudo dpkg --audit 2>&1 | grep -q "broken"; then
                echo "‚ö†Ô∏è  dpkg broken, fixing..."
                sudo dpkg --configure -a
                sudo apt-get install -f -y
                echo "‚úÖ dpkg fixed"
            else
                echo "‚úÖ dpkg healthy"
            fi
            '''
            
            success, output = client.run_command(script, timeout=180, max_retries=3)
            if success:
                print("‚úÖ dpkg health check passed")
            else:
                print("‚ö†Ô∏è  dpkg check had issues, but continuing...")
        
        print("‚úÖ Pre-flight check completed - deployment will proceed")
        EOF

    - name: Generic Environment Preparation & Dependency Installation
      run: |
        echo "üîß Running generic pre-deployment steps..."
        export GITHUB_ACTIONS=true
        export PYTHONPATH="${PYTHONPATH}:$(pwd)/workflows"
        
        python3 workflows/deploy-pre-steps-generic.py \
          --instance-name ${{ needs.load-config.outputs.instance_name }} \
          --region ${{ needs.load-config.outputs.aws_region }} \
          --config-file ${{ inputs.config_file }} \
          --os-type ${{ needs.load-config.outputs.os_type }} \
          --package-manager ${{ needs.load-config.outputs.package_manager }}

  application-package:
    needs: [load-config]
    runs-on: ubuntu-latest
    if: needs.load-config.outputs.should_deploy == 'true'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ vars.AWS_ROLE_ARN || secrets.AWS_ROLE_ARN }}
        role-duration-seconds: 3600  # 1 hour session
        aws-region: ${{ needs.load-config.outputs.aws_region }}

    - name: Build React app if needed
      run: |
        if [ -f "example-react-app/package.json" ] && grep -q "example-react-app" "${{ inputs.config_file }}"; then
          echo "üì¶ Building React application..."
          cd example-react-app
          npm install
          npm run build
          echo "‚úÖ React build completed"
        else
          echo "‚ÑπÔ∏è  No React build needed"
        fi

    - name: Create deployment package
      run: |
        echo "üì¶ Creating application package..."
        
        python3 << 'EOF'
        import yaml
        import os
        import subprocess
        
        with open('${{ inputs.config_file }}', 'r') as f:
            config = yaml.safe_load(f)
        
        package_files = config.get('application', {}).get('package_files', [])
        package_fallback = config.get('application', {}).get('package_fallback', True)
        
        if package_files:
            existing_files = []
            for file_pattern in package_files:
                if os.path.exists(file_pattern):
                    existing_files.append(file_pattern)
            
            if existing_files:
                print(f"üì¶ Packaging specific files: {existing_files}")
                cmd = ['tar', '-czf', 'app.tar.gz'] + existing_files
                result = subprocess.run(cmd, capture_output=True, text=True)
                # Exit code 1 with "file changed" warning is acceptable
                if result.returncode not in [0, 1]:
                    print(f"‚ùå tar failed with exit code {result.returncode}")
                    print(result.stderr)
                    exit(result.returncode)
                elif result.returncode == 1 and 'file changed as we read it' not in result.stderr.lower():
                    print(f"‚ùå tar failed: {result.stderr}")
                    exit(1)
                print("‚úÖ Package created successfully")
            elif package_fallback:
                print("üì¶ Specific files not found, packaging all files as fallback")
                cmd = ['tar', '-czf', 'app.tar.gz', '--exclude=.git', '--exclude=.github', '--exclude=node_modules', '--exclude=*.tar.gz', '.']
                result = subprocess.run(cmd, capture_output=True, text=True)
                if result.returncode not in [0, 1]:
                    print(f"‚ùå tar failed with exit code {result.returncode}")
                    print(result.stderr)
                    exit(result.returncode)
                elif result.returncode == 1 and 'file changed as we read it' not in result.stderr.lower():
                    print(f"‚ùå tar failed: {result.stderr}")
                    exit(1)
                print("‚úÖ Package created successfully")
            else:
                print("‚ùå Specific files not found and fallback disabled")
                exit(1)
        else:
            print("üì¶ No specific files configured, packaging all files")
            cmd = ['tar', '-czf', 'app.tar.gz', '--exclude=.git', '--exclude=.github', '--exclude=*.tar.gz', '.']
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode not in [0, 1]:
                print(f"‚ùå tar failed with exit code {result.returncode}")
                print(result.stderr)
                exit(result.returncode)
            elif result.returncode == 1 and 'file changed as we read it' not in result.stderr.lower():
                print(f"‚ùå tar failed: {result.stderr}")
                exit(1)
            print("‚úÖ Package created successfully")
        EOF

    - name: Upload application package
      uses: actions/upload-artifact@v4
      with:
        name: application-package
        path: app.tar.gz
        retention-days: 1

  post-steps-generic:
    needs: [load-config, pre-steps-generic, application-package]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: |
      always() &&
      needs.load-config.outputs.should_deploy == 'true' &&
      needs.pre-steps-generic.result == 'success' &&
      needs.application-package.result == 'success'
    environment: ${{ inputs.environment }}
    steps:
    - name: Checkout application code
      uses: actions/checkout@v4
    
    - name: Checkout deployment scripts
      uses: actions/checkout@v4
      with:
        repository: naveenraj44125-creator/lamp-stack-lightsail
        path: .deployment-scripts
    
    - name: Copy deployment scripts
      run: |
        cp -r .deployment-scripts/workflows ./
        echo "‚úÖ Deployment scripts copied"

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ vars.AWS_ROLE_ARN || secrets.AWS_ROLE_ARN }}
        role-duration-seconds: 3600  # 1 hour session
        aws-region: ${{ needs.load-config.outputs.aws_region }}

    - name: Setup Python environment
      run: |
        python3 -m pip install --upgrade pip
        python3 -m pip install boto3 pyyaml

    - name: Download application package
      uses: actions/download-artifact@v4
      with:
        name: application-package

    - name: Generic Application Deployment & Configuration
      run: |
        echo "üöÄ Running generic application deployment..."
        export GITHUB_ACTIONS=true
        export PYTHONPATH="${PYTHONPATH}:$(pwd)/workflows"
        export DOCKER_IMAGE_TAG="${{ inputs.docker_image_tag }}"
        
        python3 workflows/deploy-post-steps-generic.py \
          app.tar.gz \
          --instance-name ${{ needs.load-config.outputs.instance_name }} \
          --region ${{ needs.load-config.outputs.aws_region }} \
          --config-file ${{ inputs.config_file }} \
          --os-type ${{ needs.load-config.outputs.os_type }} \
          --package-manager ${{ needs.load-config.outputs.package_manager }} \
          --verify \
          --cleanup \
          --env GITHUB_SHA=${{ github.sha }} \
          --env GITHUB_REF=${{ github.ref_name }} \
          --env GITHUB_ACTOR=${{ github.actor }} \
          --env GITHUB_RUN_ID=${{ github.run_id }} \
          --env APP_TYPE=${{ needs.load-config.outputs.app_type }} \
          --env APP_VERSION=${{ needs.load-config.outputs.app_version }} \
          --env DOCKER_IMAGE_TAG="${{ inputs.docker_image_tag }}"

  verification:
    needs: [load-config, post-steps-generic]
    runs-on: ubuntu-latest
    if: always()
    outputs:
      app_url: ${{ steps.set-outputs.outputs.app_url }}
      status: ${{ steps.set-outputs.outputs.status }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ vars.AWS_ROLE_ARN || secrets.AWS_ROLE_ARN }}
        role-duration-seconds: 3600  # 1 hour session
        aws-region: ${{ needs.load-config.outputs.aws_region }}

    - name: Setup Python environment
      run: |
        python3 -m pip install --upgrade pip
        python3 -m pip install boto3 pyyaml

    - name: External Connectivity Test
      id: connectivity
      run: |
        echo "üåê Testing external connectivity..."
        VERIFICATION_PORT="${{ needs.load-config.outputs.verification_port }}"
        VERIFICATION_PATH="${{ needs.load-config.outputs.verification_path }}"
        TEST_URL="http://${{ needs.load-config.outputs.static_ip }}:${VERIFICATION_PORT}${VERIFICATION_PATH}"
        
        echo "üìç Test URL: $TEST_URL"
        echo "‚è≥ Waiting 60 seconds for services to fully initialize..."
        sleep 60

        for i in {1..15}; do
          echo "Attempt $i/15: Testing $TEST_URL"
          
          # Try to fetch the page and check if we get a 200 response
          HTTP_CODE=$(curl -s -o /tmp/response.html -w "%{http_code}" --connect-timeout 10 --max-time 30 "$TEST_URL" || echo "000")
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Got HTTP 200 response!"
            
            # Check if response contains expected content (case-insensitive)
            if grep -qi "html\|Example\|App\|Hello\|Welcome\|Recipe\|Docker\|healthy\|ok" /tmp/response.html; then
              echo "‚úÖ Application is accessible and responding with content!"
              cat /tmp/response.html | head -20
              echo "status=success" >> $GITHUB_OUTPUT
              exit 0
            else
              echo "‚ö†Ô∏è Got 200 but unexpected content:"
              cat /tmp/response.html | head -20
            fi
          elif [ "$HTTP_CODE" = "000" ]; then
            echo "‚ùå Connection timeout or refused"
          else
            echo "‚ùå Got HTTP $HTTP_CODE"
          fi
          
          echo "Waiting for application to respond... ($i/15)"
          sleep 15
        done

        echo "‚ùå Application failed to respond after 15 attempts (4+ minutes)"
        echo "status=failed" >> $GITHUB_OUTPUT
        exit 1

    - name: Set Outputs
      if: always() && steps.connectivity.outcome != 'skipped'
      run: |
        echo "app_url=http://${{ needs.load-config.outputs.static_ip }}/" >> $GITHUB_OUTPUT
        echo "status=${{ steps.connectivity.outputs.status || 'failed' }}" >> $GITHUB_OUTPUT

    - name: Deployment Summary
      if: always()
      run: |
        echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Application**: ${{ needs.load-config.outputs.app_name }} v${{ needs.load-config.outputs.app_version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **OS Type**: ${{ needs.load-config.outputs.os_type }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Package Manager**: ${{ needs.load-config.outputs.package_manager }}" >> $GITHUB_STEP_SUMMARY
        echo "- **URL**: http://${{ needs.load-config.outputs.static_ip }}/" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: ${{ steps.connectivity.outputs.status || 'failed' }}" >> $GITHUB_STEP_SUMMARY
